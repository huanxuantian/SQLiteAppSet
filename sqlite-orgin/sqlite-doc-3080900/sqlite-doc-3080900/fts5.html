<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>SQLite FTS5 Extension</title>
<style type="text/css">
body {
    margin: auto;
    font-family: Verdana, sans-serif;
    padding: 8px 1%;
}

a { color: #044a64 }
a:visited { color: #734559 }

.logo { position:absolute; margin:3px; }
.tagline {
  float:right;
  text-align:right;
  font-style:italic;
  width:300px;
  margin:12px;
  margin-top:58px;
}

.menubar {
  clear: both;
  border-radius: 8px;
  background: #044a64;
  padding: 0px;
  margin: 0px;
  cell-spacing: 0px;
}    
.toolbar {
  text-align: center;
  line-height: 1.6em;
  margin: 0;
  padding: 0px 8px;
}
.toolbar a { color: white; text-decoration: none; padding: 6px 12px; }
.toolbar a:visited { color: white; }
.toolbar a:hover { color: #044a64; background: white; }

.content    { margin: 5%; }
.content dt { font-weight:bold; }
.content dd { margin-bottom: 25px; margin-left:20%; }
.content ul { padding:0px; padding-left: 15px; margin:0px; }

/* Things for "fancyformat" documents start here. */
.fancy img+p {font-style:italic}
.fancy .codeblock i { color: darkblue; }
.fancy h1,.fancy h2,.fancy h3,.fancy h4 {font-weight:normal;color:#044a64}
.fancy h2 { margin-left: 10px }
.fancy h3 { margin-left: 20px }
.fancy h4 { margin-left: 30px }
.fancy th {white-space:nowrap;text-align:left;border-bottom:solid 1px #444}
.fancy th, .fancy td {padding: 0.2em 1ex; vertical-align:top}
.fancy #toc a        { color: darkblue ; text-decoration: none }
.fancy .todo         { color: #AA3333 ; font-style : italic }
.fancy .todo:before  { content: 'TODO:' }
.fancy p.todo        { border: solid #AA3333 1px; padding: 1ex }
.fancy img { display:block; }
.fancy :link:hover, .fancy :visited:hover { background: wheat }
.fancy p,.fancy ul,.fancy ol,.fancy dl { margin: 1em 5ex }
.fancy li p { margin: 1em 0 }
/* End of "fancyformat" specific rules. */

</style>
  
</head>
<body>
<div><!-- container div to satisfy validator -->

<a href="index.html">
<img class="logo" src="images/sqlite370_banner.gif" alt="SQLite Logo"
 border="0"></a>
<div><!-- IE hack to prevent disappearing logo--></div>
<div class="tagline">Small. Fast. Reliable.<br>Choose any three.</div>

<table width=100% class="menubar"><tr>
  <td width=100%>
  <div class="toolbar">
    <a href="about.html">About</a>
    <a href="sitemap.html">Sitemap</a>
    <a href="docs.html">Documentation</a>
    <a href="download.html">Download</a>
    <a href="copyright.html">License</a>
    <a href="news.html">News</a>
    <a href="support.html">Support</a>
  </div>
<script>
  gMsg = "Search SQLite Docs..."
  function entersearch() {
    var q = document.getElementById("q");
    if( q.value == gMsg ) { q.value = "" }
    q.style.color = "black"
    q.style.fontStyle = "normal"
  }
  function leavesearch() {
    var q = document.getElementById("q");
    if( q.value == "" ) { 
      q.value = gMsg
      q.style.color = "#044a64"
      q.style.fontStyle = "italic"
    }
  }
  function hideorshow(btn,obj){
    var x = document.getElementById(obj);
    var b = document.getElementById(btn);
    if( x.style.display!='none' ){
      x.style.display = 'none';
      b.innerHTML='show';
    }else{
      x.style.display = '';
      b.innerHTML='hide';
    }
    return false;
  }
</script>
<td>
    <div style="padding:0 1em 0px 0;white-space:nowrap">
    <form name=f method="GET" action="https://www.sqlite.org/search">
      <input id=q name=q type=text
       onfocus="entersearch()" onblur="leavesearch()" style="width:24ex;padding:1px 1ex; border:solid white 1px; font-size:0.9em ; font-style:italic;color:#044a64;" value="Search SQLite Docs...">
      <input type=submit value="Go" style="border:solid white 1px;background-color:#044a64;color:white;font-size:0.9em;padding:0 1ex">
    </form>
    </div>
  </table>

<div class=startsearch></div>
  





    <div class=fancy>
    <div style="font-size:2em;text-align:center;color:#044a64">
      SQLite FTS5 Extension
    </div>
    <div style="font-size:1.5em;margin:1em;color:#044a64">
      Table Of Contents</div>
    <div id=toc> <div style="margin-left:6ex"><a href="#section_1">1. Overview of FTS5</a></div><div style="margin-left:12ex"><a href="#section_1_1">1.1. Overview of Functionality</a></div><div style="margin-left:12ex"><a href="#section_1_2">1.2. Differences between FTS5 and FTS3/4</a></div><div style="margin-left:6ex"><a href="#section_2">2. Full-text Query Syntax</a></div><div style="margin-left:6ex"><a href="#section_3">3. FTS5 Table Creation and Initialization</a></div><div style="margin-left:12ex"><a href="#section_3_1">3.1. Prefix Indexes</a></div><div style="margin-left:12ex"><a href="#section_3_2">3.2. Tokenizers</a></div><div style="margin-left:18ex"><a href="#section_3_2_1">3.2.1. Unicode61 Tokenizer</a></div><div style="margin-left:18ex"><a href="#section_3_2_2">3.2.2. Ascii Tokenizer</a></div><div style="margin-left:18ex"><a href="#section_3_2_3">3.2.3. Porter Tokenizer</a></div><div style="margin-left:12ex"><a href="#section_3_3">3.3. External Content and Contentless Tables</a></div><div style="margin-left:18ex"><a href="#section_3_3_1">3.3.1. Contentless Tables</a></div><div style="margin-left:18ex"><a href="#section_3_3_2">3.3.2. External Content Tables</a></div><div style="margin-left:6ex"><a href="#section_4">4.  Auxiliary Functions </a></div><div style="margin-left:12ex"><a href="#section_4_1">4.1. Built-in Auxiliary Functions</a></div><div style="margin-left:18ex"><a href="#section_4_1_1">4.1.1. The bm25() function</a></div><div style="margin-left:18ex"><a href="#section_4_1_2">4.1.2. The highlight() function</a></div><div style="margin-left:18ex"><a href="#section_4_1_3">4.1.3. The snippet() function</a></div><div style="margin-left:12ex"><a href="#section_4_2">4.2. Sorting by Auxiliary Function Results</a></div><div style="margin-left:6ex"><a href="#section_5">5. Special INSERT Commands</a></div><div style="margin-left:12ex"><a href="#section_5_1">5.1. The 'automerge' Configuration Option</a></div><div style="margin-left:12ex"><a href="#section_5_2">5.2. The 'crisismerge' Configuration Option</a></div><div style="margin-left:12ex"><a href="#section_5_3">5.3. The 'delete' Command</a></div><div style="margin-left:12ex"><a href="#section_5_4">5.4. The 'delete-all' Command</a></div><div style="margin-left:12ex"><a href="#section_5_5">5.5. The 'integrity-check' Command</a></div><div style="margin-left:12ex"><a href="#section_5_6">5.6. The 'optimize' Command</a></div><div style="margin-left:12ex"><a href="#section_5_7">5.7. The 'pgsz' Configuration Option</a></div><div style="margin-left:12ex"><a href="#section_5_8">5.8. The 'rank' Configuration Option</a></div><div style="margin-left:12ex"><a href="#section_5_9">5.9. The 'rebuild' Command</a></div><div style="margin-left:6ex"><a href="#section_6">6. Extending FTS5</a></div><div style="margin-left:12ex"><a href="#section_6_1">6.1. Custom Tokenizers</a></div><div style="margin-left:12ex"><a href="#section_6_2">6.2. Custom Auxiliary Functions</a></div><div style="margin-left:18ex"><a href="#section_6_2_1">6.2.1. Custom Auxiliary Functions API Reference</a></div> </div>
    <div class=startsearch></div>
  

<h2 style="margin-left:1.0em">  Overview</h2> 

<h1 id="section_1">1. Overview of FTS5</h1>

<p>FTS5 is an SQLite <a href="c3ref/module.html">virtual table module</a> that provides 
<a href="http://en.wikipedia.org/wiki/Full_text_search">full-text search</a>
functionality to database applications. In their most elementary form, 
full-text search engines allow the user to efficiently search a large 
collection of documents for the subset that contain one or more instances of a
search term. The search functionality provided to world wide web users by
<a href="www.google.com">Google</a> is, amongst other things, a full-text search
engine, as it allows users to search for all documents on the web that contain,
for example, the term "fts5".

<h2 id="section_1_1">1.1. Overview of Functionality</h2>

<p>To use FTS5, the user creates an FTS5 virtual table with one or more
columns. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">CREATE VIRTUAL TABLE email USING fts5(sender, title, body);
</pre></table></div>

<p>It is an error to add types, constraints or <a href="lang_createtable.html#primkeyconst">PRIMARY KEY</a> declarations to 
a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created,
an FTS5 table may be populated using <a href="lang_insert.html">INSERT</a>, <a href="lang_update.html">UPDATE</a> or <a href="lang_delete.html">DELETE</a> statements
like any other table. Like any other table with no PRIMARY KEY declaration, an
FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid. 

<p>Not shown in the example above is that there are also 
<a href="fts5.html#section_3">various options</a> that may be provided to FTS5 as
part of the CREATE VIRTUAL TABLE statement to configure various aspects of the
new table. These may be used to modify the way in which the FTS5 table extracts
terms from documents and queries, to create extra indexes on disk to speed up
prefix queries, or to create an FTS5 table that acts as an index on content
stored elsewhere.

<p>Once populated, a full-text query may be executed on the contents of an
FTS5 table by adding a MATCH constraint to the WHERE clause of a SELECT 
query. The expression to the right of the MATCH operator must be the name
of the FTS5 table. The expression on the left must be a text value specifying
the term to search for. For example: 

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Query for all rows that contain at least once instance of the term</i>
<i>-- "fts5" (in any column).</i>
SELECT * FROM email WHERE email MATCH 'fts5';
</pre></table></div>

<p> By default, FTS5 full-text searches are case-independent. Like any other
SQL query that does not contain an ORDER BY clause, the example above returns
results in an arbitrary order. To sort results by relevance (most to least
relevant), an ORDER BY may be added to a full-text query as follows:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Query for all rows that contain at least once instance of the term</i>
<i>-- "fts5" (in any column). Return results in order from best to worst</i>
<i>-- match.  </i>
SELECT * FROM email WHERE email MATCH 'fts5' ORDER BY rank;
</pre></table></div>

<p> As well as the column values and rowid of a matching row, an application
may use <a href="fts5.html#section_4">FTS5 auxiliary functions</a> to retrieve extra information regarding
the matched row. For example, an auxiliary function may be used to retrieve
a copy of a column value for a matched row with all instances of the matched
term surrounded by html &lt;b&gt;&lt;/b&gt; tags. Auxiliary functions are
invoked in the same way as SQLite <a href="lang_corefunc.html">scalar functions</a>, except that the name
of the FTS5 table is specified as the first argument. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Query for rows that match "fts5". Return a copy of the "body" column</i>
<i>-- of each row with the matches surrounded by &lt;b&gt;&lt;/b&gt; tags.</i>
SELECT highlight(email, 2, '&lt;b&gt;', '&lt;/b&gt;') FROM email WHERE email MATCH 'fts5'
</pre></table></div>

<p>A description of the available auxiliary functions, and more details
regarding configuration of the special "rank" column, are 
<a href="fts5.html#section_4">available below</a>. <a href="fts5.html#section_6_2">Custom auxiliary functions</a> may also be implemented in C and registered with
FTS5, just as custom SQL functions may be registered with the SQLite core.

<p> As well as seaching for all rows that contain a term, FTS5 allows 
the user to search for rows that contain:

<ul>
  <li> any terms that begin with a specified prefix,
  <li> "phrases" - sequences of terms or prefix terms that must feature in a
       document for it to match the query, 
  <li> sets of terms, prefix terms or phrases that appear within a specified
       proximity of each other (these are called "NEAR queries"), or
  <li> boolean combinations of any of the above.
</ul>

<p> Such advanced searches are requested by providing a more complicated 
FTS5 query string as the text to the right of the MATCH operator. The full
query syntax is <a href="fts5.html#section_2">described here</a>.

<h2 id="section_1_2">1.2. Differences between FTS5 and FTS3/4</h2>

<p> Also available is the similar but more mature <a href="fts3.html">FTS3/4</a> module. 
Apart from the exciting new name, FTS5 differs from FTS3/4 in the following
ways:

<ul>
  <li> <p>FTS5 supports "ORDER BY rank" for returning results in order of
       decreasing relevancy.

  <li> <p>FTS5 features an API allowing users to create custom auxiliary 
       functions for advanced ranking and text processing applications. The
       special "rank" column may be mapped to a custom auxiliary function
       so that adding "ORDER BY rank" to a query works as expected.

  <li> <p>FTS5 recognizes unicode separator characters and case equivalence by
       default. This is also possible using FTS3/4, but must be explicitly
       enabled.

  <li> <p>The query syntax has been revised where necessary to remove
       ambiguities and to make it possible to escape special characters
       in query terms.

  <li> <p>By default, FTS3/4 occasionally merges together two or more of the
       b-trees that make up its full-text index within an INSERT, UPDATE or
       DELETE statement executed by the user. This means that any operation
       on an FTS3/4 table may turn out to be surprisingly slow, as FTS3/4 
       may unpredictably choose to merge together two or more large b-trees
       within it. FTS5 uses incremental merging by default, which limits
       the amount of processing that may take place within any given 
       INSERT, UPDATE or DELETE operation.

  <li> <p>FTS5 uses significantly less memory when one or more terms in
       a query match a very large number of documents. 
</ul>

<h1 id="section_2">2. Full-text Query Syntax</h1>

<p>
The following block contains a summary of the FTS query syntax in BNF form.
A detailed explanation follows.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">&lt;phrase&gt;    := string &#91;*]
&lt;phrase&gt;    := &lt;phrase&gt; + &lt;phrase&gt;
&lt;neargroup&gt; := NEAR ( &lt;phrase&gt; &lt;phrase&gt; ... &#91;, N] )
&lt;query&gt;     := &#91;colname :] &lt;phrase&gt;
&lt;query&gt;     := &#91;colname :] &lt;neargroup&gt;
&lt;query&gt;     := ( &lt;query&gt; )
&lt;query&gt;     := &lt;query&gt; AND &lt;query&gt;
&lt;query&gt;     := &lt;query&gt; OR &lt;query&gt;
&lt;query&gt;     := &lt;query&gt; NOT &lt;query&gt;
</pre></table></div>

<p>
Within an FTS expression a <b>string</b> may be specified in one of two ways:

<ul>
  <li> <p>By enclosing it in double quotes ("). Within a string, any embedded
       double quote characters may be escaped SQL-style - by adding a second
       double-quote character.

  <li> <p>As a bareword that includes no whitespace or reserved characters, 
       and is not "AND", "OR" or "NOT" (case sensitive). Reserved characters
       are: 
<pre>
    : ~ ! @ # $ % &#94; &amp; * ( ) + , =
</pre>
       In other words, the top row of a regular US keyboard, the plus sign,
       comma and colon characters. Strings that include any of these 
       characters must be quoted.
</ul>

<p>
FTS queries are made up of <b>phrases</b>. A phrase is an ordered list of 
one or more tokens. A string is transformed into a phrase by passing it to
the FTS table tokenizer. Two phrases can be concatenated into a single 
large phrase using the "+" operator. For example, assuming the tokenizer
module being used tokenizes the input "one.two.three" to three separate
tokens, the following three queries all specify the same phrase:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">... MATCH '"one two three"'
... MATCH 'one + two + three'
... MATCH '"one two" + three'
... MATCH 'one.two.three'
</pre></table></div>

<p>
A phrase matches a document if the document contains at least one sub-sequence
of tokens that matches the sequence of tokens that make up the phrase.

<p>
If a "*" character follows a string within an FTS expression, then the final
token extracted from the string is marked as a <b>prefix token</b>. As you
might expect, a prefix token matches any document token of which it is a 
prefix. For example, the first two queries in the following block will match
any document that contains the token "one" immediately followed by the token
"two" and then any token that begins with "thr".

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">... MATCH '"one two thr" * '
... MATCH 'one + two + thr*'
... MATCH '"one two thr*"'      <b>-- May not work as expected!</b>
</pre></table></div>

<p>The final query in the block above may not work as expected. Because the
"*" character is inside the double-quotes, it will be passed to the tokenizer,
which will likely discard it (or perhaps, depending on the specific tokenizer
in use, include it as part of the final token) instead of recognizing it as
a special FTS character.

<p>Two or more phrases may be grouped into a <b>NEAR group</b>. A NEAR group
is specified by the token "NEAR" (case sensitive) followed by an open
parenthesis character, followed by two or more whitespace separated phrases, optionally followed by a comma and the numeric parameter <i>N</i>, followed by
a close parenthesis. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">... MATCH 'NEAR("one two" "three four", 10)'
... MATCH 'NEAR("one two" thr* + four)'
</pre></table></div>

<p>If no <i>N</i> parameter is supplied, it defaults to 10. A NEAR group
matches a document if the document contains at least one clump of tokens that: 

<ol> 
  <li> contains at least one instance of each phrase, and 
  <li> for which the number of tokens between the end of the first phrase 
       and the beginning of the last phrase in the clump is less than <i>N</i>.
</ol>

<p>For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">CREATE VIRTUAL TABLE f USING fts5(x);
INSERT INTO f(rowid, x) VALUES(1, 'A B C D x x x E F x');

... MATCH 'NEAR(e d, 4)';                      <i>-- Matches!</i>
... MATCH 'NEAR(e d, 3)';                      <i>-- Matches!</i>
... MATCH 'NEAR(e d, 2)';                      <i>-- Does not match!</i>

... MATCH 'NEAR("c d" "e f", 3)';              <i>-- Matches!</i>
... MATCH 'NEAR("c"   "e f", 3)';              <i>-- Does not match!</i>

... MATCH 'NEAR(a d e, 6)';                    <i>-- Matches!</i>
... MATCH 'NEAR(a d e, 5)';                    <i>-- Does not match!</i>

... MATCH 'NEAR("a b c d" "b c" "e f", 4)';    <i>-- Matches!</i>
... MATCH 'NEAR("a b c d" "b c" "e f", 3)';    <i>-- Does not match!</i>
</pre></table></div>


<p>
A single phrase or NEAR group may be restricted to matching text within a
specified column of the FTS table by prefixing it with the column name 
followed by a colon character. Column names may be specified using either
of the two forms described for strings above. Unlike strings that are part
of phrases, column names are not passed to the tokenizer module. Column 
names are case-insensitive in the usual way for SQLite column names -
upper/lower case equivalence is understood for ASCII-range characters only.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">... MATCH 'colname : NEAR("one two" "three four", 10)'
... MATCH '"colname" : one + two + three'
</pre></table></div>

<p>
Phrases and NEAR groups may be arranged into expressions using <b>boolean
operators</b>. In order of precedence, from highest to lowest, the operators 
are:

<table style="margin:1em auto; width:80%; border-spacing:0">
  <tr style="text-align:left"><th>Operator <th>Function
  <tr style="text-align:left;background-color:#DDDDDD"><td><code>&lt;query1&gt; AND &lt;query2&gt;</code> 
      <td>Matches if both query1 and query2 match.

  <tr style="text-align:left"><td><code>&lt;query1&gt; OR &lt;query2&gt;</code> 
      <td>Matches if either query1 or query2 match.

  <tr style="text-align:left;background-color:#DDDDDD"><td><code>&lt;query1&gt; NOT &lt;query2&gt;</code> 
      <td>Matches if query1 matches and query2 does not match.

</table>

<p>
Parenthesis may be used to group expressions in order to modify operator
precedence in the usual ways. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Matches documents that contain at least one instance of either "one"</i>
<i>-- or "two", but do not contain any instances of token "three".</i>
... MATCH 'one OR two NOT three'

<i>-- Match all documents that contain the token "two" but not "three", or</i>
<i>-- contain the token "one".</i>
... MATCH 'one OR (two NOT three)'
</pre></table></div>

<p>
Phrases and NEAR groups may also be connected by <b>implicit AND operators</b>.
For simplicity, these are not shown in the BNF grammar above. Essentially, any
sequence of phrases or NEAR groups (including those restricted to matching
specified columns) separated only by whitespace are handled as if there were an
implicit AND operator between each pair of phrases or NEAR groups. Implicit
AND operators are never inserted after or before an expression enclosed in
parenthesis. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">... MATCH 'one two three'         <i>-- 'one AND two AND three'</i>
... MATCH 'three "one two"'       <i>-- 'three AND "one two"'</i>
... MATCH 'NEAR(one two) three'   <i>-- 'NEAR(one two) AND three'</i>
... MATCH 'one OR two three'      <i>-- 'one OR two AND three'</i>

... MATCH '(one OR two) three'    <i>-- Syntax error!</i>
... MATCH 'func(one two)'         <i>-- Syntax error!</i>
</pre></table></div>

<h1 id="section_3">3. FTS5 Table Creation and Initialization</h1>

<p>Each argument specified as part of a "CREATE VIRTUAL TABLE ... USING fts5 
..." statement is either a column name or a configuration option. A column
name consists of a single FTS5 bareword or a single string literal quoted
in any manner acceptable to SQLite. A configuration option consists of an
FTS5 bareword - the option name - followed by an "=" character, followed by
the option value. The option value is specified using either a single FTS5 
bareword or a string literal, again quoted in any manner acceptable to the
SQLite core. Anything else is a syntax error.

<p>It is an error to attempt to name an fts5 table column "rowid" or "rank",
or to assign the same name to a column as is used by the table itself. This 
is not supported.

<p>It is also an error to add a type, constraint specification or PRIMARY KEY
clause to a column name in an FTS5 CREATE VIRTUAL TABLE statement.

<p> A configuration option consists of an FTS5 bareword - the option name -
followed by an "=" character, followed by a either an FTS5 bareword or a
string literal. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">CREATE VIRTUAL TABLE mail USING fts5(sender, title, body, tokenize = 'porter ascii');
</pre></table></div>

<p> There are currently the following configuration options:

<ul>
  <li> The "tokenize" option, used to configure a <a href="fts5.html#section_3_2">custom tokenizer</a>.
  <li> The "prefix" option, used to add <a href="fts5.html#section_3_1">prefix indexes</a>
       to an FTS5 table.
  <li> The "content" option, used to make the FTS5 table an 
       <a href="fts5.html#section_3_3">external content or contentless table</a>.
  <li> The "content_rowid" option, used to set the rowid field of an 
  <a href="fts5.html#section_3_3_2">external content table</a>.
</ul>

<h2 id="section_3_1">3.1. Prefix Indexes</h2>

<p> By default, FTS5 maintains a single index recording the location of each
token instance within the document set. This means that querying for complete
tokens is fast, as it requires a single lookup, but querying for a prefix 
token can be slow, as it requires a range scan. For example, to query for
the prefix token "abc*" requires a range scan of all tokens greater than
or equal to "abc" and less than "abd".

<p> A prefix index is a separate index that records the location of all
instances of prefix tokens of a certain length in characters used to speed
up queries for prefix tokens. For example, optimizing a query for prefix
token "abc*" requires a prefix index of three-character prefixes.

<p> To add prefix indexes to an FTS5 table, the "prefix" option is set to
either a single positive integer or a text value containing a white-space
separated list of one or more positive integer values. A prefix index is
created for each integer specified. If more than one "prefix" option is
specified as part of a single CREATE VIRTUAL TABLE statement, all apply.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Two ways to create an FTS5 table that maintains prefix indexes for
-- two and three character prefix tokens.</i>
CREATE VIRTUAL TABLE ft USING fts5(a, b, prefix='2 3');
CREATE VIRTUAL TABLE ft USING fts5(a, b, prefix=2, prefix=3);
</pre></table></div>

<h2 id="section_3_2">3.2. Tokenizers</h2>

<p> The CREATE VIRTUAL TABLE "tokenize" option is used to configure the
specific tokenizer used by the FTS5 table. The option argument must be either
an FTS5 bareword, or an SQL text literal. The text of the argument is itself
treated as a white-space series of one or more FTS5 barewords or SQL text
literals. The first of these is the name of the tokenizer to use. The second
and subsequent list elements, if they exist, are arguments passed to the
tokenizer implementation.

<p> Unlike option values and column names, SQL text literals intended as
tokenizers must be quoted using single quote characters. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- The following are all equivalent</i>
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter ascii');
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = "porter ascii");
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = "'porter' 'ascii'");
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = '''porter'' ''ascii''');

<i>-- But this will fail:</i>
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = '"porter" "ascii"');

<i>-- This will fail too:</i>
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter' 'ascii');
</pre></table></div>


<p>
FTS5 features three built-in tokenizer modules, described in subsequent
sections:

<ul>
  <li> The <b>unicode61</b> tokenizer, based on the Unicode 6.1 standard. This
       is the default.

  <li> The <b>ascii</b> tokenizer, which assumes all characters outside of
  the ASCII codepoint range (0-127) are to be treated as token characters.

  <li> The <b>porter</b> tokenizer, which implements the 
<a href="http://tartarus.org/martin/PorterStemmer/">porter stemming algorithm</a>.
</ul>

<p> It is also possible to create custom tokenizers for FTS5. The API for doing so is <a href="fts5.html#section_6_1">described here</a>.

<h3 id="section_3_2_1">3.2.1. Unicode61 Tokenizer</h3>

<p> The unicode tokenizer classifies all unicode characters as either 
"separator" or "token" characters. By default all space and punctuation
characters, as defined by Unicode 6.1, are considered separators, and all 
other characters as token characters. Each contiguous run of one or more 
token characters is considered to be a token. The tokenizer is case-insensitive
according to the rules defined by Unicode 6.1.

<p> By default, diacritics are removed from all Latin script characters. This
means, for example, that "A", "a", "&#192;", "&#224;", "&#194;" and "&#226;"
are all considered to be equivalent.

<p> Any arguments following "unicode61" in the token specification are treated
as a list of alternating option names and values. Unicode61 supports the
following options:

<table style="margin:1em auto; width:80%; border-spacing:0">
  <tr style="text-align:left"><th> Option <th> Usage
  <tr style="text-align:left;background-color:#DDDDDD"><td> remove_diacritics
  <td>This option should be set to "0" or "1". If it is set (the default),
  diacritics are removed from all latin script characters as described above.
  If it is clear, they are not. 

  <tr style="text-align:left"><td> tokenchars
  <td> This option is used to specify additional unicode characters that 
  should be considered token characters, even if they are white-space or
  punctuation characters according to Unicode 6.1. All characters in the
  string that this option is set to are considered token characters.

  <tr style="text-align:left;background-color:#DDDDDD"><td> separators
  <td> This option is used to specify additional unicode characters that 
  should be considered as separator characters, even if they are token
  characters according to Unicode 6.1. All characters in the string that 
  this option is set to are considered separators.
</table>

<p> For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Create an FTS5 table that does not remove diacritics from Latin
-- script characters, and that considers hyphens and underscore characters
-- to be part of tokens. </i>
CREATE VIRTUAL TABLE ft USING fts5(a, b, 
    tokenize = "unicode61 remove_diacritics 0 tokenchars '-_'"
);
</pre></table></div>

<h3 id="section_3_2_2">3.2.2. Ascii Tokenizer</h3>

<p> The Ascii tokenizer is similar to the Unicode61 tokenizer, except that:

<ul>
  <li> All non-ASCII characters (those with codepoints greater than 127) are
  always considered token characters. If any non-ASCII characters are specified
  as part of the separators option, they are ignored.  

  <li> Case-folding is only performed for ASCII characters. So while "A" and
  "a" are considered to be equivalent, "&#195" and "&#227;" are distinct.

  <li> The remove_diacritics option is not supported.
</ul>

<p> For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Create an FTS5 table that uses the ascii tokenizer, but does not
-- consider numeric characters to be part of tokens.</i>
CREATE VIRTUAL TABLE ft USING fts5(a, b, 
    tokenize = "ascii separators '0123456789'"
);
</pre></table></div>

<h3 id="section_3_2_3">3.2.3. Porter Tokenizer</h3>

<p> The porter tokenizer is a wrapper tokenizer. It takes the output of some
other tokenizer and applies the 
<a href="http://tartarus.org/martin/PorterStemmer/">porter stemming algorithm</a>
to each token before it returns it to FTS5. This allows search terms like
"correction" to match similar words such as "corrected" or "correcting". The
porter stemmer algorithm is designed for use with English language terms 
only - using it with other languages may or may not improve search utility.

<p> By default, the porter tokenizer operates as a wrapper around the default
tokenizer (unicode61). Or, if one or more extra arguments are added to the
"tokenize" option following "porter", they are treated as a specification for
the underlying tokenizer that the porter stemmer uses. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Two ways to create an FTS5 table that uses the porter tokenizer to
-- stem the output of the default tokenizer (unicode61). </i>
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = porter); 
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter unicode61');

<i>-- A porter tokenizer used to stem the output of the unicode61 tokenizer,
-- with diacritics removed before stemming.</i>
CREATE VIRTUAL TABLE t1 USING fts5(x, tokenize = 'porter unicode61 remove_diacritics 1');
</pre></table></div>

<h2 id="section_3_3">3.3. External Content and Contentless Tables</h2>

<p>
Normally, when a row is inserted into an FTS5 table, as well as the various
full-text index entries and other data a copy of the row is stored in a private
table managed by the FTS5 module. When column values are requested from the
FTS5 table by the user or by an auxiliary function implementation, they are
read from this private table. The "content" option may be used to create an
FTS5 table that stores only FTS full-text index entries. Because the column
values themselves are usually much larger than the associated full-text index
entries, this can save significant database space.

<p>
There are two ways to use the "content" option:
<ul>
  <li> By setting it to an empty string to create a contentless FTS5 table. In
       this case FTS5 assumes that the original column values are unavailable
       to it when processing queries. Full-text queries and some auxiliary
       functions can still be used, but no column values apart from the rowid
       may be read from the table.

  <li> By setting it to the name of a database object (table, virtual table or
       view) that may be queried by FTS5 at any time to retrieve the column
       values. This is known as an "external content" table. In this case all
       FTS5 functionality may be used, but it is the responsibility of the user
       to ensure that the contents of the full-text index are consistent with
       the named database object. If they are not, query results may be
       unpredictable.  
</ul>

<h3 id="section_3_3_1">3.3.1. Contentless Tables</h3>

<p> A contentless FTS5 table is created by setting the "content" option to
an empty string. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">CREATE VIRTUAL TABLE f1 USING fts5(a, b, c, content='');
</pre></table></div>

<p> Contentless FTS5 tables do not support UPDATE or DELETE statements, or
INSERT statements that do not supply a non-NULL value for the rowid field.
Rows may be deleted from a contentless table using an <a href="fts5.html#section_5_3">FTS5 delete command</a>.

<p> Attempting to read any column value except the rowid from a contentless
FTS5 table returns an SQL NULL value.

<h3 id="section_3_3_2">3.3.2. External Content Tables</h3>

<p> An external content FTS5 table is created by setting the content 
option to the name of a table, virtual table or view (hereafter the "content
table") within the same database. Whenever column values are required by
FTS5, it queries the content table as follows, with the rowid of the row
for which values are required bound to the SQL variable:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">SELECT * FROM &lt;content&gt; WHERE &lt;content_rowid&gt; = ?;
</pre></table></div>

<p> In the above, &lt;content&gt; is replaced by the name of the content table.
By default, &lt;content_rowid&gt; is replaced by the literal text "rowid". Or,
if the "content_rowid" option is set within the CREATE VIRTUAL TABLE statement,
by the value of that option.

<p> The "*" in the above query must expand to a set of columns consisting of
the &lt;column_rowid&gt; column followed by each indexed column, in the same
order as they are present in the external content fts5 table.

<p> The content table may also be queried as follows:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">SELECT * FROM &lt;content&gt; ORDER BY &lt;content_rowid&gt; ASC;
SELECT * FROM &lt;content&gt; ORDER BY &lt;content_rowid&gt; DESC;
</pre></table></div>

<p> It is still the responsibility of the user to ensure that the contents of
an external content FTS5 table are kept up to date with the content table. 
One way to do this is with triggers. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Create a table. And an external content fts5 table to index it.</i>
CREATE TABLE tbl(a INTEGER PRIMARY KEY, b, c);
CREATE VIRTUAL TABLE fts_idx USING fts5(b, c, content='tbl', content_rowid='a');

<i>-- Triggers to keep the FTS index up to date.</i>
CREATE TRIGGER tbl_ai AFTER INSERT ON tbl BEGIN
  INSERT INTO fts_idx(rowid, b, c) VALUES (new.a, new.b, new.c);
END;
CREATE TRIGGER tbl_ad AFTER DELETE ON tbl BEGIN
  INSERT INTO fts_idx(fts_idx, rowid, b, c) VALUES('delete', old.a, old.b, old.c);
END;
CREATE TRIGGER tbl_au AFTER UPDATE ON tbl BEGIN
  INSERT INTO fts_idx(fts_idx, rowid, b, c) VALUES('delete', old.a, old.b, old.c);
  INSERT INTO fts_idx(rowid, b, c) VALUES (new.a, new.b, new.c);
END;
</pre></table></div>


<h1 id="section_4">4.  Auxiliary Functions </h1>

<p> Auxiliary functions are similar to <a href="lang_corefunc.html">SQL scalar functions</a>,
except that they may only be used within full-text queries (those that use
the MATCH operator) on an FTS5 table. Their results are calculated based not
only on the arguments passed to them, but also on the current match and 
matched row. For example, an auxiliary function may return a numeric value
indicating the accuracy of the match (see the <a href="fts5.html#section_4_1_1">bm25()</a> function), 
or a fragment of text from the matched row that contains one or more 
instances of the search terms (see the <a href="fts5.html#section_4_1_3">snippet()</a> function).

<p>To invoke an auxiliary function, the name of the FTS5 table should be
specified as the first argument. Other arguments may follow the first,
depending on the specific auxiliary function being invoked. For example, to
invoke the "highlight" function:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">SELECT highlight(email, 2, '&lt;b&gt;', '&lt;/b&gt;') FROM email WHERE email MATCH 'fts5'
</pre></table></div>

<p>The built-in auxiliary functions provided as part of FTS5 are described in
the following section. Applications may also implement 
<a href="fts5.html#section_6_2">custom auxiliary functions in C</a>.

<h2 id="section_4_1">4.1. Built-in Auxiliary Functions</h2>

<p> FTS5 provides three built-in auxiliary functions:

<ul>
  <li> The <a href="fts5.html#section_4_1_1">bm25() auxiliary function</a> returns a real value
       reflecting the accuracy of the current match. Better matches are
       assigned numerically lower values.

  <li> The <a href="fts5.html#section_4_1_2">highlight() auxiliary function</a> returns a copy
       of the text from one of the columns of the current match with each
       instance of a queried term within the result surrounded by specified
       markup (for example "&lt;b&gt;" and "&lt;/b&gt;").

  <li> The <a href="fts5.html#section_4_1_3">snippet() auxiliary function</a> selects a short
       fragment of text from one of the columns of the matched row and returns
       it with each instance of a queried term surrounded by markup in
       the same manner as the highlight() function. The fragment of text is
       selected so as to maximize the number of queried terms it contains.
</ul>

<h3 id="section_4_1_1">4.1.1. The bm25() function</h3>

<p> The built-in auxiliary function bm25() returns a real value indicating
how well the current row matches the full-text query. The better the match,
the larger the value returned. A query such as the following may be used
to return matches in order from best to worst match:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">SELECT * FROM fts WHERE fts MATCH ? ORDER BY bm25(fts)
</pre></table></div>

<p> In order to calculate a documents score, the full-text query is separated
    into its component phrases. The bm25 score for document <i>D</i> and 
    query <i>Q</i> is then calculated as follows:

<p> <img src="images/fts5_formula1.png" style="width:75ex;margin-left:5ex">

<p> In the above, <i>nPhrase</i> is the number of phrases in the query.
    <i>|D|</i> is the number of tokens in the current document, and
    <i>avgdl</i> is the average number of tokens in all documents within the
    FTS5 table.  <i>k<sub>1</sub></i> and <i>b</i> are both constants,
    hard-coded at 1.2 and 0.75 respectively.

<p> The "-1" term at the start of the formula is not found in most
implementations of the BM25 algorithm. Without it, a better match is assigned
a numerically higher BM25 score. Since the default sorting order is
"ascending", this means that appending "ORDER BY bm25(fts)" to a query would
cause results to be returned in order from worst to best. The "DESC" keyword
would be required in order to return the best matches first. In order to
avoid this pitfall, the FTS5 implementation of BM25 multiplies the result
by -1 before returning it, ensuring that better matches are assigned
numerically lower scores.

<p> <i>IDF(q<sub>i</sub>)</i> is the inverse-document-frequency of query 
    phrase <i>i</i>. It is calculated as follows, where <i>N</i> is the total
    number of rows in the FTS5 table and <i>n(q<sub>i</sub>)</i> is the total
    number of rows that contain at least one instance of phrase <i>i</i>:

<p> <img src="images/fts5_formula2.png" style="width:75ex;margin-left:5ex">

<p> Finally, <i>f(q<sub>i</sub>,D)</i> is the phrase frequency of phrase 
<i>i</i>. By default, this is simply the number of occurrences of the phrase
within the current row. However, by passing extra real value arguments to 
the bm25() SQL function, each column of the table may be assigned a different
weight and the phrase frequency calculated as follows:

<p> <img src="images/fts5_formula3.png" style="width:75ex;margin-left:5ex">

<p> where <i>w<sub>c</sub></i> is the weight assigned to column <i>c</i> and
<i>n(q<sub>i</sub>,c)</i> is the number of occurrences of phrase <i>i</i> in
column <i>c</i> of the current row. The first argument passed to bm25()
following the table name is the weight assigned to the leftmost column of
the FTS5 table. The second is the weight assigned to the second leftmost
column, and so on. If there are not enough arguments for all table columns,
remaining columns are assigned a weight of 1.0. If there are too many 
trailing arguments, the extras are ignored. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Assuming the following schema:</i>
CREATE VIRTUAL TABLE email USING fts5(sender, title, body);

<i>-- Return results in bm25 order, with each phrase hit in the "sender"</i>
<i>-- column considered the equal of 10 hits in the "body" column, and</i>
<i>-- each hit in the "title" column considered as valuable as 5 hits in</i>
<i>-- the "body" column.</i>
SELECT * FROM email WHERE email MATCH ? ORDER BY bm25(email, 10.0, 5.0);
</pre></table></div>

<p>Refer to wikipedia for 
<a href="http://en.wikipedia.org/wiki/Okapi_BM25">more information regarding
BM25</a> and its variants.

<h3 id="section_4_1_2">4.1.2. The highlight() function</h3>

<p> The highlight() function returns a copy of the text from a specified 
column of the current row with extra markup text inserted to mark the start 
and end of phrase matches. 

<p>The highlight() must be invoked with exactly three arguments following 
the table name. To be interpreted as follows:

<ol>
  <li> An integer indicating the index of the FTS table column to read the 
       text from. Columns are numbered from left to right starting at zero.

  <li> The text to insert before each phrase match.

  <li> The text to insert after each phrase match.
</ol>

<p>For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Return a copy of the text from the leftmost column of the current</i>
<i>-- row, with phrase matches marked using html "b" tags.</i>
SELECT highlight(fts, 0, '&lt;b&gt;' '&lt;/b&gt;') FROM fts WHERE fts MATCH ?
</pre></table></div>

<p>In cases where two or more phrase instances overlap (share one or more
tokens in common), a single open and close marker is inserted for each set
of overlapping phrases. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Assuming this:</i>
CREATE VIRTUAL TABLE ft USING fts5(a);
INSERT INTO ft VALUES('a b c x c d e');
INSERT INTO ft VALUES('a b c c d e');
INSERT INTO ft VALUES('a b c d e');

<i>-- The following SELECT statement returns these three rows:</i>
<i>--   '&#91;a b c&#93; x &#91;c d e&#93;'</i>
<i>--   '&#91;a b c&#93; &#91;c d e&#93;'</i>
<i>--   '&#91;a b c d e&#93;'</i>
SELECT highlight(ft, 0, '&#91;', '&#93;') FROM ft WHERE ft MATCH 'a+b+c AND c+d+e';
</pre></table></div>

<h3 id="section_4_1_3">4.1.3. The snippet() function</h3>

<p>The snippet() function is similar to highlight(), except that instead of
returning entire column values, it automatically selects and extracts a
short fragment of document text to process and return. The snippet() function
must be passed five parameters following the table name argument:

<ol>
  <li> An integer indicating the index of the FTS table column to select
       the returned text from. Columns are numbered from left to right 
       starting at zero. A negative value indicates that the column should
       be automatically selected.

  <li> The text to insert before each phrase match within the returned text.

  <li> The text to insert after each phrase match within the returned text.

  <li> The text to add to the start or end of the selected text to indicate
       that the returned text does not occur at the start or end of its column,
       respectively.

  <li> The maximum number of tokens in the returned text. This must be greater
       than zero and equal to or less than 64. 
</ol>

<h2 id="section_4_2">4.2. Sorting by Auxiliary Function Results</h2>

<p> All FTS5 tables feature a special hidden column named "rank". If the
current query is not a full-text query (i.e. if it does not include a MATCH
operator), the value of the "rank" column is always NULL. Otherwise, in a
full-text query, column rank contains by default the same value as would be
returned by executing the bm25() auxiliary function with no trailing 
arguments.

<p> The difference between reading from the rank column and using the bm25()
function directly within the query is only significant when sorting by the
returned value. In this case, using "rank" is faster than using bm25().

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- The following queries are logically equivalent. But the second may</i>
<i>-- be faster, particularly if the caller abandons the query before</i>
<i>-- all rows have been returned (or if the queries were modified to </i>
<i>-- include LIMIT clauses).</i>
SELECT * FROM fts WHERE fts MATCH ? ORDER BY bm25(fts);
SELECT * FROM fts WHERE fts MATCH ? ORDER BY rank;
</pre></table></div>

<p> Instead of using bm25() with no trailing arguments, the specific auxiliary
function mapped to the rank column may be configured either on a per-query
basis, or by setting a different persistent default for the FTS table.

<p> In order to change the mapping of the rank column for a single query, 
a term similar to the following is added to the WHERE clause of a query:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">rank MATCH 'auxiliary-function-name(arg1, arg2, ...)'
</pre></table></div>

<p> The right-hand-side of the MATCH clause must be a constant expression that
evaluates to a string consisting of the auxiliary function to invoke, followed
by zero or more comma separated arguments within parenthesis. Arguments must
be SQL literals. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- The following queries are logically equivalent. But the second may</i>
<i>-- be faster. See above. </i>
SELECT * FROM fts WHERE fts MATCH ? ORDER BY bm25(fts, 10.0, 5.0);
SELECT * FROM fts WHERE fts MATCH ? AND rank MATCH 'bm25(10.0, 5.0)' ORDER BY rank;
</pre></table></div>

<p> The default mapping of the rank column for a table may be modified 
using the <a href="fts5.html#section_5_8">FTS5 rank configuration option</a>.

<h1 id="section_5">5. Special INSERT Commands</h1>

<h2 id="section_5_1">5.1. The 'automerge' Configuration Option</h2>

<p>
  Instead of using a single data structure on disk to store the full-text
  index, FTS5 uses a series of b-trees. Each time a new transaction is
  committed, a new b-tree containing the contents of the committed transaction
  is written into the database file. When the full-text index is queried, each
  b-tree must be queried individually and the results merged before being
  returned to the user.

<p>
  In order to prevent the number of b-trees in the database from becoming too
  large (slowing down queries), smaller b-trees are periodically merged into
  single larger b-trees containing the same data. By default, this happens
  automatically within INSERT, UPDATE or DELETE statements that modify the
  full-text index. The 'automerge' parameter determines how many smaller
  b-trees are merged together at a time. Setting it to a small value can
  speed up queries (as they have to query and merge the results from fewer 
  b-trees), but can also slow down writing to the database (as each INSERT,
  UPDATE or DELETE statement has to do more work as part of the automatic
  merging process).

<p>
  Each of the b-trees that make up the full-text index is assigned to a "level"
  based on its size. Level-0 b-trees are the smallest, as they contain the
  contents of a single transaction. Higher level b-trees are the result of
  merging two or more level-0 b-trees together and so they are larger. FTS5
  begins to merge b-trees together once there exist <i>M</i> or more b-trees 
  with the same level, where <i>M</i> is the value of the 'automerge' 
  parameter.

<p>
  The maximum allowed value for the 'automerge' parameter is 16. The default
  value is 4. Setting the 'automerge' parameter to 0 disables the automatic 
  incremental merging of b-trees altogether.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">INSERT INTO ft(ft, rank) VALUES('automerge', 8);
</pre></table></div>

<h2 id="section_5_2">5.2. The 'crisismerge' Configuration Option</h2>

<p>The 'crisismerge' option is similar to 'automerge', in that it determines
how and how often the component b-trees that make up the full-text index are
merged together. Once there exist <i>C</i> or more b-trees on a single level
within the full-text index, where <i>C</i> is the value of the 'crisismerge'
option, all b-trees on the level are immediately merged into a single b-tree.

<p>The difference between this option and the 'automerge' option is that when
the 'automerge' limit is reached FTS5 only begins to merge the b-trees
together. Most of the work is performed as part of subsequent INSERT, 
UPDATE or DELETE operations. Whereas when the 'crisismerge' limit is reached,
the offending b-trees are all merged immediately. This means that an INSERT,
UPDATE or DELETE that triggers a crisis-merge may take a long time to 
complete.

<p>The default 'crisismerge' value is 16. There is no maximum limit. Attempting
to set the 'crisismerge' parameter to a value of 0 or 1 is equivalent to
setting it to the default value (16). It is an error to attempt to set the
'crisismerge' option to a negative value.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">INSERT INTO ft(ft, rank) VALUES('crisismerge', 16);
</pre></table></div>

<h2 id="section_5_3">5.3. The 'delete' Command</h2>

<p> This command is only available with <a href="fts5.html#section_3_3_2">external content</a> and <a href="fts5.html#section_3_3_1">contentless</a> tables. It
is used to delete the index entries associated with a single row from the
full-text index. This command and the <a href="fts5.html#section_5_4">delete-all</a>
command are the only ways to remove entries from the full-text index of a
contentless table.

<p> In order to use this command to delete a row, the text value 'delete' 
must be inserted into the special column with the same name as the table.
The rowid of the row to delete is inserted into the rowid column. The
values inserted into the other columns must match the values currently
stored in the table. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>-- Insert a row with rowid=14 into the fts5 table.</i>
INSERT INTO ft(rowid, a, b, c) VALUES(14, $a, $b, $c);

<i>-- Remove the same row from the fts5 table.</i>
INSERT INTO ft(ft, rowid, a, b, c) VALUES('delete', 14, $a, $b, $c);
</pre></table></div>

<p> If the values "inserted" into the text columns as part of a 'delete'
command are not the same as those currently stored within the table, the
results may be unpredictable.

<p> The reason for this is easy to understand: When a document is inserted
into the FTS5 table, an entry is added to the full-text index to record the
position of each token within the new document. When a document is removed,
the original data is required in order to determine the set of entries that
need to be removed from the full-text index. So if the data supplied to FTS5
when a row is deleted using this command is different from that used to
determine the set of token instances when it was inserted, some full-text 
index entries may not be correctly deleted, or FTS5 may try to remove index 
entries that do not exist. This can leave the full-text index in an
unpredictable state, making future query results unreliable.

<h2 id="section_5_4">5.4. The 'delete-all' Command</h2>

<p> This command is only available with <a href="fts5.html#section_3_3_2">external content</a> and <a href="fts5.html#section_3_3_1">contentless</a> tables. It
deletes all entries from the full-text index.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">INSERT INTO ft(ft) VALUES('delete-all');
</pre></table></div>

<h2 id="section_5_5">5.5. The 'integrity-check' Command</h2>

<p> This command is used to verify that the full-text index is consistent 
with the contents of the FTS5 table or <a href="fts5.html#section_3_3_2">content 
table</a>. It is not available with <a href="fts5.html#section_3_3_1">contentless tables</a>.

<p>The integrity-check command is invoked by inserting the text value
'integrity-check' into the special column with the same name as the FTS5
table. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">INSERT INTO ft(ft) VALUES('integrity-check');
</pre></table></div>

<p>If the full-text index is consistent with the contents of the table, the
INSERT used to invoke the integrity-check command succeeds. Or, if any
discrepancy is found, it fails with an <a href="rescode.html#corrupt_vtab">SQLITE_CORRUPT_VTAB</a> error.

<h2 id="section_5_6">5.6. The 'optimize' Command</h2>

<p>This command merges all individual b-trees that currently make up the
full-text index into a single large b-tree structure. This ensures that the
full-text index consumes the mimimum space within the database and is in the
fastest form to query.

<p>Refer to the documentation for the <a href="fts5.html#section_5_1">FTS5 automerge option</a> for more details
regarding the relationship between the full-text index and its component
b-trees.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">INSERT INTO ft(ft) VALUES('optimize');
</pre></table></div>

<h2 id="section_5_7">5.7. The 'pgsz' Configuration Option</h2>

<p> This command is used to set the persistent "pgsz" option.

<p> The full-text index maintained by FTS5 is stored as a series of fixed-size
blobs in a database table. It is not strictly necessary for all blobs that make
up a full-text index to be the same size. The pgsz option determines the size
of all blobs created by subsequent index writers. The default value is 1000.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">INSERT INTO ft(ft, rank) VALUES('pgsz', 4072);
</pre></table></div>

<h2 id="section_5_8">5.8. The 'rank' Configuration Option</h2>

<p> This command is used to set the persistent "rank" option.

<p> The rank option is used to change the default auxiliary function mapping
for the rank column. The option should be set to a text value in the same
format as described for <a href="fts5.html#section_4_2">"rank MATCH ?"</a> terms 
above. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">INSERT INTO ft(ft, rank) VALUES('rank', 'bm25(10.0, 5.0)');
</pre></table></div>

<h2 id="section_5_9">5.9. The 'rebuild' Command</h2>

<p> This command first deletes the entire full-text index, then rebuilds it
based on the contents of the table or <a href="fts5.html#section_3_3_2">content
table</a>.  It is not available with <a href="fts5.html#section_3_3_1">contentless
tables</a>.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">INSERT INTO ft(ft) VALUES('rebuild');
</pre></table></div>


<h1 id="section_6">6. Extending FTS5</h1>

<p>FTS5 features APIs allowing it to be extended by:

<ul>
  <li> Adding new auxiliary functions implemented in C, and
  <li> Adding new tokenizers, also implemented in C.
</ul>

<p> The built-in tokenizers and auxiliary functions described in this
document are all implemented using the publicly available API described
below.

<p> Before a new auxiliary function or tokenizer implementation may be 
registered with FTS5, an application must obtain a pointer to the "fts5_api"
structure. There is one fts5_api structure for each database connection with
which the FTS5 extension is registered. To obtain the pointer, the application
invokes the SQL user-defined function fts5(), which returns a blob value
containing the pointer to the fts5_api structure for the connection. The
following example code demonstrates the technique:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>/*
** Return a pointer to the fts5_api pointer for database connection db.
** If an error occurs, return NULL and leave an error in the database 
** handle (accessible using sqlite3_errcode()/errmsg().
*/</i>
fts5_api *fts5_api_from_db(sqlite3 *db){
  fts5_api *pRet = 0;
  sqlite3_stmt *pStmt = 0;

  if( SQLITE_OK==sqlite3_prepare(db, "SELECT fts5()", -1, &pStmt, 0)
   && SQLITE_ROW==sqlite3_step(pStmt) 
   && sizeof(pRet)==sqlite3_column_bytes(pStmt, 0)
  ){
    memcpy(&pRet, sqlite3_column_blob(pStmt, 0), sizeof(pRet));
  }
  sqlite3_finalize(pStmt);
  return pRet;
}
</pre></table></div>

<p> The fts5_api structure is defined as follows. It exposes three methods, 
one each for registering new auxiliary functions and tokenizers, and one for
retrieving existing tokenizer. The latter is intended to facilitate the
implementation of "tokenizer wrappers" similar to the built-in
porter tokenizer.

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">typedef struct fts5_api fts5_api;
struct fts5_api {
  int iVersion;                   <i>/* Currently always set to 1 */</i>

  <i>/* Create a new tokenizer */</i>
  int (*xCreateTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void *pContext,
    fts5_tokenizer *pTokenizer,
    void (*xDestroy)(void*)
  );

  <i>/* Find an existing tokenizer */</i>
  int (*xFindTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void **ppContext,
    fts5_tokenizer *pTokenizer
  );

  <i>/* Create a new auxiliary function */</i>
  int (*xCreateFunction)(
    fts5_api *pApi,
    const char *zName,
    void *pContext,
    fts5_extension_function xFunction,
    void (*xDestroy)(void*)
  );
};
</pre></table></div>

<p> To invoke a method of the fts5_api object, the fts5_api pointer itself
should be passed as the methods first argument followed by the other, method
specific, arguments. For example:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">rc = pFts5Api->xCreateTokenizer(pFts5Api, ... other args ...);
</pre></table></div>

<p> The fts5_api structure methods are described individually in the following
sections.

<h2 id="section_6_1">6.1. Custom Tokenizers</h2>

<p> To create a custom tokenizer, an application must implement three
functions: a tokenizer constructor (xCreate), a destructor (xDelete) and a
function to do the actual tokenization (xTokenize). The type of each
function is as for the member variables of the fts5_tokenizer struct:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">typedef struct Fts5Tokenizer Fts5Tokenizer;
typedef struct fts5_tokenizer fts5_tokenizer;
struct fts5_tokenizer {
  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
  void (*xDelete)(Fts5Tokenizer*);
  int (*xTokenize)(Fts5Tokenizer*, 
      void *pCtx,
      const char *pText, int nText, 
      int (*xToken)(
        void *pCtx,         <i>/* Copy of 2nd argument to xTokenize() */</i>
        const char *pToken, <i>/* Pointer to buffer containing token */</i>
        int nToken,         <i>/* Size of token in bytes */</i>
        int iStart,         <i>/* Byte offset of token within input text */</i>
        int iEnd            <i>/* Byte offset of end of token within input text */</i>
      )
  );
};
</pre></table></div>

<p> When an FTS5 table uses the custom tokenizer, the FTS5 core calls xCreate()
once to create a tokenizer, then xTokenize() zero or more times to tokenize
strings, then xDelete() to free any resources allocated by xCreate(). More
specifically:

<dl>
<dt><b>xCreate:</b></dt><dd><p style="margin-top:0">
   This function is used to allocate and inititalize a tokenizer instance.
   A tokenizer instance is required to actually tokenize text.
<p>
   The first argument passed to this function is a copy of the (void*)
   pointer provided by the application when the fts5_tokenizer object
   was registered with FTS5 (the third argument to xCreateTokenizer()). 
   The second and third arguments are an array of nul-terminated strings
   containing the tokenizer arguments, if any, specified following the
   tokenizer name as part of the CREATE VIRTUAL TABLE statement used
   to create the FTS5 table.
<p>
   The final argument is an output variable. If successful, (*ppOut) 
   should be set to point to the new tokenizer handle and SQLITE_OK
   returned. If an error occurs, some value other than SQLITE_OK should
   be returned. In this case, fts5 assumes that the final value of *ppOut 
   is undefined.
<p>
<dt><b> xDelete:</b></dt><dd><p style="margin-top:0">
   This function is invoked to delete a tokenizer handle previously
   allocated using xCreate(). Fts5 guarantees that this function will
   be invoked exactly once for each successful call to xCreate().
<p>
<dt><b> xTokenize:</b></dt><dd><p style="margin-top:0">
   This function is expected to tokenize the nText byte string indicated 
   by argument pText. pText may not be nul-terminated. The first argument
   passed to this function is a pointer to an Fts5Tokenizer object returned 
   by an earlier call to xCreate().
<p>
   For each token in the input string, the supplied callback xToken() must
   be invoked. The first argument to it should be a copy of the pointer
   passed as the second argument to xTokenize(). The next two arguments
   are a pointer to a buffer containing the token text, and the size of
   the token in bytes. The 4th and 5th arguments are the byte offsets of
   the first byte of and first byte immediately following the text from 
   which the token is derived within the input.
<p>
   FTS5 assumes the xToken() callback is invoked for each token in the 
   order that they occur within the input text.
<p>
   If an xToken() callback returns any value other than SQLITE_OK, then
   the tokenization should be abandoned and the xTokenize() method should
   immediately return a copy of the xToken() return value. Or, if the
   input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally,
   if an error occurs with the xTokenize() implementation itself, it
   may abandon the tokenization and return any error code other than
   SQLITE_OK or SQLITE_DONE.
<p>
</dl>



<h2 id="section_6_2">6.2. Custom Auxiliary Functions</h2>

<p> Implementing a custom auxiliary function is similar to implementing an
<a href="c3ref/create_function.html">scalar SQL function</a>. The implementation
should be a C function of type fts5_extension_function, defined as follows:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">typedef struct Fts5ExtensionApi Fts5ExtensionApi;
typedef struct Fts5Context Fts5Context;

typedef void (*fts5_extension_function)(
  const Fts5ExtensionApi *pApi,   <i>/* API offered by current FTS version */</i>
  Fts5Context *pFts,              <i>/* First arg to pass to pApi functions */</i>
  sqlite3_context *pCtx,          <i>/* Context for returning result/error */</i>
  int nVal,                       <i>/* Number of values in apVal[] array */</i>
  sqlite3_value **apVal           <i>/* Array of trailing arguments */</i>
);
</pre></table></div>

<p> The implementation is registered with the FTS5 module by calling the
xCreateFunction() method of the fts5_api object. If there is already an
auxiliary function with the same name, it is replaced by the new function.
If a non-NULL xDestroy parameter is passed to xCreateFunction(), it is invoked
with a copy of the pContext pointer passed as the only argument when the
database handle is closed or when the registered auxiliary function is
replaced.

<p> The final three arguments passed to the auxiliary function callback are
similar to the three arguments passed to the implementation of a scalar SQL
function. All arguments except the first passed to the auxiliary function are
available to the implementation in the apVal&#91;&#93; array. The
implementation should return a result or error via the content handle pCtx.

<p> The first argument passed to an auxiliary function callback is a pointer
to a structure containing methods that may be invoked in order to obtain
information regarding the current query or row. The second argument is an
opaque handle that should be passed as the first argument to any such method 
invocation. For example, the following auxiliary function definition returns
the total number of tokens in all columns of the current row:

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em"><i>/*
** Implementation of an auxiliary function that returns the number
** of tokens in the current row (including all columns).
*/</i>
static void column_size_imp(
  const Fts5ExtensionApi *pApi,
  Fts5Context *pFts,
  sqlite3_context *pCtx,
  int nVal,
  sqlite3_value **apVal
){
  int rc;
  int nToken;
  rc = pApi->xColumnSize(pFts, -1, &nToken);
  if( rc==SQLITE_OK ){
    sqlite3_result_int(pCtx, nToken);
  }else{
    sqlite3_result_error_code(pCtx, rc);
  }
}
</pre></table></div>

<p>The following section describes the API offered to auxiliary function
implementations in detail. Further examples may be found in the "fts5_aux.c"
file of the source code.

<h3 id="section_6_2_1">6.2.1. Custom Auxiliary Functions API Reference</h3>

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">struct Fts5ExtensionApi {
  int iVersion;                   <i>/* Currently always set to 1 */</i>

  void *(*<a href="#xUserData">xUserData</a>)(Fts5Context*);

  int (*<a href="#xColumnCount">xColumnCount</a>)(Fts5Context*);
  int (*<a href="#xRowCount">xRowCount</a>)(Fts5Context*, sqlite3_int64 *pnRow);
  int (*<a href="#xColumnTotalSize">xColumnTotalSize</a>)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);

  int (*<a href="#xTokenize">xTokenize</a>)(Fts5Context*, 
    const char *pText, int nText, <i>/* Text to tokenize */</i>
    void *pCtx,                   <i>/* Context passed to xToken() */</i>
    int (*xToken)(void*, const char*, int, int, int)       <i>/* Callback */</i>
  );

  int (*<a href="#xPhraseCount">xPhraseCount</a>)(Fts5Context*);
  int (*<a href="#xPhraseSize">xPhraseSize</a>)(Fts5Context*, int iPhrase);

  int (*<a href="#xInstCount">xInstCount</a>)(Fts5Context*, int *pnInst);
  int (*<a href="#xInst">xInst</a>)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);

  sqlite3_int64 (*<a href="#xRowid">xRowid</a>)(Fts5Context*);
  int (*<a href="#xColumnText">xColumnText</a>)(Fts5Context*, int iCol, const char **pz, int *pn);
  int (*<a href="#xColumnSize">xColumnSize</a>)(Fts5Context*, int iCol, int *pnToken);

  int (*<a href="#xQueryPhrase">xQueryPhrase</a>)(Fts5Context*, int iPhrase, void *pUserData,
    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
  );
  int (*<a href="#xSetAuxdata">xSetAuxdata</a>)(Fts5Context*, void *pAux, void(*xDelete)(void*));
  void *(*<a href="#xGetAuxdata">xGetAuxdata</a>)(Fts5Context*, int bClear);
};
</pre></table></div>

<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xUserData">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>void *(*xUserData)(Fts5Context*)</pre></h>
<p>
Return a copy of the context pointer the extension function was 
   registered with.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xColumnTotalSize">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken)</pre></h>
<p>
If parameter iCol is less than zero, set output variable *pnToken
   to the total number of tokens in the FTS5 table. Or, if iCol is
   non-negative but less than the number of columns in the table, return
   the total number of tokens in column iCol, considering all rows in 
   the FTS5 table.
</p>

<p>
   If parameter iCol is greater than or equal to the number of columns
   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.
   an OOM condition or IO error), an appropriate SQLite error code is 
   returned.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xColumnCount">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xColumnCount)(Fts5Context*)</pre></h>
<p>
Returns the number of columns in the FTS5 table.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xColumnSize">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken)</pre></h>
<p>
Reports the size in tokens of a column value from the current row.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xColumnText">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn)</pre></h>
<p>
Reports the size in tokens of a column value from the current row.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xPhraseCount">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xPhraseCount)(Fts5Context*)</pre></h>
<p>
Returns the number of phrases in the current query expression.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xPhraseSize">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xPhraseSize)(Fts5Context*, int iPhrase)</pre></h>
<p>
Returns the number of tokens in phrase iPhrase of the query. Phrases
   are numbered starting from zero.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xInstCount">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xInstCount)(Fts5Context*, int *pnInst)</pre></h>
<p>
Set *pnInst to the total number of occurrences of all phrases within
   the query within the current row. Return SQLITE_OK if successful, or
   an error code (i.e. SQLITE_NOMEM) if an error occurs.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xInst">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff)</pre></h>
<p>
Query for the details of phrase match iIdx within the current row.
   Phrase matches are numbered starting from zero, so the iIdx argument
   should be greater than or equal to zero and smaller than the value
   output by xInstCount().
</p>

<p>
   Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) 
   if an error occurs.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xRowid">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>sqlite3_int64 (*xRowid)(Fts5Context*)</pre></h>
<p>
Returns the rowid of the current row.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xTokenize">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xTokenize)(Fts5Context*, 
    const char *pText, int nText, 
    void *pCtx,                   
    int (*xToken)(void*, const char*, int, int, int)       
  )</pre></h>
<p>
Tokenize text using the tokenizer belonging to the FTS5 table.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xQueryPhrase">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
  )</pre></h>
<p>
This API function is used to query the FTS table for phrase iPhrase
   of the current query. Specifically, a query equivalent to:
</p>

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">... FROM ftstable WHERE ftstable MATCH $p ORDER BY rowid
</pre></table></div>

<p>
   with $p set to a phrase equivalent to the phrase iPhrase of the
   current query is executed. For each row visited, the callback function
   passed as the fourth argument is invoked. The context and API objects 
   passed to the callback function may be used to access the properties of
   each matched row. Invoking Api.xUserData() returns a copy of the pointer
   passed as the third argument to pUserData.
</p>

<p>
   If the callback function returns any value other than SQLITE_OK, the
   query is abandoned and the xQueryPhrase function returns immediately.
   If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK.
   Otherwise, the error code is propagated upwards.
</p>

<p>
   If the query runs to completion without incident, SQLITE_OK is returned.
   Or, if some error occurs before the query completes or is aborted by
   the callback, an SQLite error code is returned.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xSetAuxdata">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*))</pre></h>
<p>
Save the pointer passed as the second argument as the extension functions 
   "auxiliary data". The pointer may then be retrieved by the current or any
   future invocation of the same fts5 extension function made as part of
   of the same MATCH query using the xGetAuxdata() API.
</p>

<p>
   Each extension function is allocated a single auxiliary data slot for
   each FTS query (MATCH expression). If the extension function is invoked 
   more than once for a single FTS query, then all invocations share a 
   single auxiliary data context.
</p>

<p>
   If there is already an auxiliary data pointer when this function is
   invoked, then it is replaced by the new pointer. If an xDelete callback
   was specified along with the original pointer, it is invoked at this
   point.
</p>

<p>
   The xDelete callback, if one is specified, is also invoked on the
   auxiliary data pointer after the FTS5 query has finished.
</p>

<p>
   If an error (e.g. an OOM condition) occurs within this function, an
   the auxiliary data is set to NULL and an error code returned. If the
   xDelete parameter was not NULL, it is invoked on the auxiliary data
   pointer before returning.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xGetAuxdata">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>void *(*xGetAuxdata)(Fts5Context*, int bClear)</pre></h>
<p>
Returns the current auxiliary data pointer for the fts5 extension 
   function. See the xSetAuxdata() method for details.
</p>

<p>
   If the bClear argument is non-zero, then the auxiliary data is cleared
   (set to NULL) before this function returns. In this case the xDelete,
   if any, is not invoked.
</p>
<hr color="#eeeee" style="margin:1em 8.4ex 0 8.4ex;" id="xRowCount">
<h style="padding-left:6ex;font-size:1.4em;display:block"><pre>int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow)</pre></h>
<p>
This function is used to retrieve the total number of rows in the table.
   In other words, the same value that would be returned by:
</p>

<div class=codeblock style="margin:0 15ex"><table width=100% style="border:1px solid #80a796;padding:0 1ex;background-color:#EEEEEE"><tr><td><pre style="font-size:1.1em">SELECT count(*) FROM ftstable;
</pre></table></div>


